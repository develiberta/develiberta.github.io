<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Main Memroy" /><meta name="author" content="Develiberta" /><meta property="og:locale" content="en" /><meta name="description" content="목적 논리 주소와 물리 주소의 차이점과 주소를 변환할 때 MMU(메모리 관리 장치)의 역할을 설명한다. 메모리를 연속적으로 할당하기 위해 최초, 최적 및 최악 접합 전략을 적용한다. 내부 및 외부 단편화의 차이점을 설명한다. TLB (translation look-aside buffer)가 포함된 페이징 시스템에서 논리 주소를 물리 주소로 변환한다. 계층적 페이징, 해시 페이징 및 역 페이지 테이블을 설명한다. IA-32, x86-64 및 ARMv8 아키텍처의 주소 변환에 관해 설명한다." /><meta property="og:description" content="목적 논리 주소와 물리 주소의 차이점과 주소를 변환할 때 MMU(메모리 관리 장치)의 역할을 설명한다. 메모리를 연속적으로 할당하기 위해 최초, 최적 및 최악 접합 전략을 적용한다. 내부 및 외부 단편화의 차이점을 설명한다. TLB (translation look-aside buffer)가 포함된 페이징 시스템에서 논리 주소를 물리 주소로 변환한다. 계층적 페이징, 해시 페이징 및 역 페이지 테이블을 설명한다. IA-32, x86-64 및 ARMv8 아키텍처의 주소 변환에 관해 설명한다." /><link rel="canonical" href="https://develiberta.github.io/posts/os-main-memory/" /><meta property="og:url" content="https://develiberta.github.io/posts/os-main-memory/" /><meta property="og:site_name" content="Develiberta" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-05T18:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Main Memroy" /><meta name="twitter:site" content="@develiberta" /><meta name="twitter:creator" content="@Develiberta" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Develiberta"},"dateModified":"2023-02-12T19:08:32+09:00","datePublished":"2023-02-05T18:00:00+09:00","description":"목적 논리 주소와 물리 주소의 차이점과 주소를 변환할 때 MMU(메모리 관리 장치)의 역할을 설명한다. 메모리를 연속적으로 할당하기 위해 최초, 최적 및 최악 접합 전략을 적용한다. 내부 및 외부 단편화의 차이점을 설명한다. TLB (translation look-aside buffer)가 포함된 페이징 시스템에서 논리 주소를 물리 주소로 변환한다. 계층적 페이징, 해시 페이징 및 역 페이지 테이블을 설명한다. IA-32, x86-64 및 ARMv8 아키텍처의 주소 변환에 관해 설명한다.","headline":"Main Memroy","mainEntityOfPage":{"@type":"WebPage","@id":"https://develiberta.github.io/posts/os-main-memory/"},"url":"https://develiberta.github.io/posts/os-main-memory/"}</script><title>Main Memroy | Develiberta</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png?v=1743601323"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png?v=1743601323"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png?v=1743601323"><link rel="manifest" href="/assets/img/favicons/site.webmanifest?v=1743601323"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico?v=1743601323"><meta name="apple-mobile-web-app-title" content="Develiberta"><meta name="application-name" content="Develiberta"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css?v=1743601323"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css?v=1743601323"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/?v=1743601323" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-512x512.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/?v=1743601323">Develiberta</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/?v=1743601323" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/?v=1743601323" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/?v=1743601323" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/?v=1743601323" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/?v=1743601323" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/develiberta?v=1743601323" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/develiberta?v=1743601323" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['develiberta','gmail.com'].join('@')?v=1743601323" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml?v=1743601323" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/?v=1743601323"> Home </a> </span> <span>Main Memroy</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Main Memroy</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Develiberta </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Feb 5, 2023, 6:00 PM +0900" >Feb 5, 2023<i class="unloaded">2023-02-05T18:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Feb 12, 2023, 7:08 PM +0900" >Feb 12, 2023<i class="unloaded">2023-02-12T19:08:32+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3577 words">19 min read</span></div></div><div class="post-content"><h2 id="목적">목적</h2><hr /><ol><li>논리 주소와 물리 주소의 차이점과 주소를 변환할 때 MMU(메모리 관리 장치)의 역할을 설명한다.<li>메모리를 연속적으로 할당하기 위해 최초, 최적 및 최악 접합 전략을 적용한다.<li>내부 및 외부 단편화의 차이점을 설명한다.<li>TLB (translation look-aside buffer)가 포함된 페이징 시스템에서 논리 주소를 물리 주소로 변환한다.<li>계층적 페이징, 해시 페이징 및 역 페이지 테이블을 설명한다.<li>IA-32, x86-64 및 ARMv8 아키텍처의 주소 변환에 관해 설명한다.</ol><h2 id="실천-목표">실천 목표</h2><hr /><ol><li>기본 하드웨어에서 메인 메모리의 역할을 이해한다.<li>프로세스에 메모리 주소가 할당되는 과정을 이해한다.<li>기호(또는 가상) 메모리 주소와 실제 메모리 주소와의 연결을 이해한다.</ol><h2 id="메인-메모리-개요">메인 메모리 개요</h2><hr /><ol><li>메인 메모리와 각 처리 코어에 내장된 레지스터들은 CPU가 직접 접근할 수 있는 유일한 범용 저장장치<li>기계 명령어들은 메모리 주소만을 인수로 취함 (디스크의 주소를 인수로 취하지 않음)<li>메모리는 각각 주소가 할당된 일련의 바이트들로 구성됨<li>명령어 실행의 과정<ol><li>CPU가 PC(Program Counter)가 가리키는 명령어의 주소를 이용해서 메모리로부터 한 명령어를 가져옴<li>명령어를 해독하고, 메모리에서 피연산자(operand)를 가져와 피연산자에 대해 명령어를 실행한 후에 계산 결과를 메모리에 다시 저장</ol></ol><h2 id="메모리-주소의-할당">메모리 주소의 할당</h2><hr /><ol><li>원시 프로그램에서 주소는 숫자가 아닌 (변수와 같이) 심볼 형태로 표현됨<li>컴파일러는 이 심볼 주소를 재배치 가능 주소(예: 이 모듈의 첫 번째 바이트로부터 열네 번째 바이트 주소”)로 바인딩<li>링커(linker)나 로더(loader)가 재배치 가능 주소를 절대 주소(예: 74014번지)로 바인딩 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-01.jpg" alt="2023-02-05-os-main-memory-01" /><ul><li>source program에서는 symbolic address 사용<li>object module에서는 relocatable address 사용<li>executable file에서는 logical address 사용<li>program in memory(process)에서는 physical address 사용</ul></ol><h2 id="명령어와-데이터의-바인딩-시점">명령어와 데이터의 바인딩 시점</h2><hr /><ol><li>컴파일 시간 (compile time)<ul><li>프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 알 수 있으면 컴파일러는 절대 코드를 생성 가능<li>그러나 만일 이 위치가 변경되어야 한다면 이 코드는 다시 컴파일되어야 함</ul><li>적재 시간 (load time)<ul><li>프로세스가 메모리 내 어디로 올라오게 될지 컴파일 시점에 알지 못하면 컴파일러는 일단 이진 코드를 재배치 가능 코드로 생성<li>이 경우 심볼과 진짜 번지수와의 바인딩은 프로그램이 메인 메모리로 실제로 적재되는 시간에 이루어짐</ul><li>실행 시간 (execution time)<ul><li>프로세스가 실행하는 중간에 메모리 내의 한 세그먼트로부터 다른 세그먼트로 옮겨질 수 있다면 바인딩이 실행시간까지 허용된 것으로 봄<li>이것이 가능하려면 특별한 하드웨어 필요</ul></ol><h2 id="동적-연결-및-공유-라이브러리-dynamic-linking--shared-libraries">동적 연결 및 공유 라이브러리 (Dynamic Linking &amp; Shared Libraries)</h2><hr /><ol><li>동적 연결 라이브러리 (DLL)는 사용자 프로그램이 실행될 때, 사용자 프로그램에 연결되는 시스템 라이브러리<li>연결(linking)이 실행 시기까지 미루어지는 것<li>프로그램이 동적 라이브러리에 있는 루틴을 참조하면 로더는 DLL을 찾아 필요한 경우 메모리에 적재하고, 동적 라이브러리의 함수를 참조하는 주소를 DLL이 저장된 메모리의 위치로 조정<li>장점<ul><li>실행 가능 이미지의 크기를 감소시키고 메인 메모리를 절약할 수 있음<li>라이브러리를 여러 프로세스 간에 공유할 수 있어서 메인 메모리에 DLL 인스턴스가 하나만 있을 수 있음</ul></ol><h2 id="논리-주소와-물리-주소의-바인딩">논리 주소와 물리 주소의 바인딩</h2><hr /><ol><li>논리 주소 (logical address)<ul><li>CPU가 생성하는 주소</ul><li>물리 주소 (physical address)<ul><li>메모리가 취급하게 되는 주소로, 메모리 주소 레지스터(MAR)에 주어지는 주소</ul><li>논리 주소와 물리 주소의 비교<ol><li>컴파일(compile) 또는 적재(load) 시에 주소를 바인딩하면 논리 주소와 물리 주소가 같음<li>실행(execution) 시에 주소를 바인딩하면 논리 주소와 물리 주소가 다름<ul><li>이때 논리 주소를 가상 주소(virtual address)라고 부름<li>프로그램의 실행 중에 가상 주소를 물리 주소로 바꾸는 변환(mapping) 작업은 하드웨어 장치인 메모리 관리 장치(MMU, Memory Management Unit)가 수행<li>여러 가지 변환(mapping) 기법이 존재하지만 여기에서는 기준 레지스터(base register) 기법을 일반화시킨 단순한 MMU 기법에 따른 변환을 설명할 것 - (*)</ul></ol></ol><h2 id="기준-레지스터base-register-기법을-일반화시킨-단순한-mmu-기법에-따른-변환---">기준 레지스터(base register) 기법을 일반화시킨 단순한 MMU 기법에 따른 변환 - (*)</h2><hr /><ol><li>기준 레지스터(base register) 기법<ul><li>프로세스가 독립된 메모리 공간을 가지도록 보장하기 위한 단순한 기법<li>개별적인 메모리 공간을 분리하기 위해서 특정 프로세스만 접근할 수 있는 합법적인(legal) 메모리 주소 영역 설정<li>기준(base)와 상한(limit)이라 불리는 두 개의 레지스터들을 사용 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-02.jpg" alt="2023-02-05-os-main-memory-02" /><ul><li>기준 레지스터(base register)는 가장 작은 하법적인 물리 메모리 주소의 값을 저장<li>상한 레지스터(limit register)는 주어진 영역의 크기를 저장</ul><li>잘못된 접근인 경우 segmentation falut 발생하며 프로세스 중단 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-03.jpg" alt="2023-02-05-os-main-memory-03" /></ul><li>재배치(relocation) 레지스터<ul><li>위의 기준 레지스터(base register) 기법을 일반화시켜서 단순한 MMU 기법을 설명할 때, 재배치(relocation) 레지스터라고 부름 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-04.jpg" alt="2023-02-05-os-main-memory-04" /><li>사용자 프로그램은 결코 실제적인 물리 주소에 접근하지 않음<li>그러나 그것이 일단 주소로 갈 때는 재배치 레지스터(relocation register)에 의해 다시 바인딩됨<li>연속적인 메모리 할당이 가정됨</ul></ol><h2 id="연속적인-메모리-할당-contiguous-memory-allocation">연속적인 메모리 할당 Contiguous Memory Allocation</h2><hr /><p>연속적인 메모리 할당에서 각 프로세스는 다음 프로세스가 적재된 영역과 인접한 하나의 메모리 영역에 적재됨</p><ol><li>메모리 보호<ul><li>재배치 레지스터는 가장 작은 물리 주소의 값을 저장하고, 상한 레지스터는 논리 주소의 범위 값을 저장<li>MMU는 동적으로 논리 주소에 재배치 레지스터의 값을 더해서 주소를 변환하는 역할<li>변환된 주소는 메모리로 보내짐<li>CPU 스케줄러가 다음에 수행할 프로세스를 선택할 때, 디스패처(dispatcher)는 문맥 교환의 일환으로 재배치 레지스터와 상한 레지스터에 정확한 값을 적재 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-05.jpg" alt="2023-02-05-os-main-memory-05" /></ul><li>메모리 할당<ul><li>메모리를 할당하는 가장 간단한 방법 중 하나는 프로세스를 메모리의 가변 크기 파티션에 할당하는 것<li>가변 파티션 기법에서 운영체제는 사용 가능한 메모리 부분과 사용 중인 부분을 나타내는 테이블을 유지<li>(용어) hole : 하나의 큰 사용 가능한 메모리 블록 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-06.jpg" alt="2023-02-05-os-main-memory-06" /><li>동적 메모리 할당 문제 (dynamic storage allocation problem)<ul><li>일련의 메모리 가용 공간-리스트로부터 크기 n-바이트 블록을 요구하는 프로세스를 어떻게 실행할 것인가를 결정하는 문제<ul><li>최초 적합 : 첫 번째 사용 가능한 가용 공간을 할당<li>최적 적합 : 사용 가능한 공간 중에서 가장 작은 것을 택함<li>최악 적합 : 가장 큰 가용 공간을 택함</ul></ul></ul><li>단편화 fragmentation<ol><li>외부 단편화(external fragmentation) <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-06.jpg" alt="2023-02-05-os-main-memory-06" /><ul><li>프로세스들이 메모리에 적재되고 제거되는 일이 반복될 때 작은 hole이 많이 생기는 현상<li>continuous memory allocation으로 인해 발생<li>이를 해결하는 방법으로 압축(compaction), 페이징(paging)를 들 수 있음</ul><li>내부 단편화(internal fragmentation)<ul><li>일반적으로 메모리를 먼저 아주 작은 공간들로 분할하고 프로세스가 요청하면 할당을 항상 이 분할된 크기의 정수배로만 함<li>할당된 공간은 요구된 공간보다 약간 더 클 수 있는데 이들 두 크기 사이의 남는 부분이 생기는 현상<li>paging으로 인해 발생</ul></ol></ol><h2 id="페이징-paging">페이징 Paging</h2><hr /><ol><li>배경<ul><li>연속적인 메모리 할당이 외부 단편화를 발생시킴<li>메모리를 주기적으로 압축해야하 하는 번거로움<li>사실 연속적인 메모리 사용은 제한적이므로 메모리를 비연속적으로 사용하는 방법이 필요</ul><li>기본적인 아이디어<ul><li>용어<ul><li>frame 프레임 : 물리적인 메모리를 고정된 사이즈로 분할한 블록<li>page 페이지 : 논리적인 메모리를 고정된 사이즈로 분할한 블록<li>위의 두 메모리는 완전히 독립적이며 OS가 이를 매핑</ul><li>아이디어<ul><li>논리적인 메모리 (CPU에 의해 생성된 메모리)는 두 부분으로 나뉨<ul><li>page number<li>page offset</ul><li>page number는 process마다 가지고 있는 page table에서 사용됨<li>page offset은 그대로 사용됨 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-07.png" alt="2023-02-05-os-main-memory-07" /> <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-08.jpg" alt="2023-02-05-os-main-memory-08" /></ul><li>페이지<ul><li>페이지의 사이즈는 하드웨어 의존적<li>페이지의 사이즈는 4KB ~ 1GB 사이에 존재하며, 2의 제곱으로 표현되는 수<li>논리적인 메모리 공간이 \(2^m\), 페이지의 사이즈가 \(2^n\)인 경우,<ul><li>page offset을 위한 부분에는 \(n\) bits가 할당되고 (그게 offset이 가질 수 있는 최대값이믜로)<li>page number을 위한 부분에는 \(m-n\) bits가 할당됨 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-09.jpg" alt="2023-02-05-os-main-memory-09" /> <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-10.jpg" alt="2023-02-05-os-main-memory-10" /> <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-11.jpg" alt="2023-02-05-os-main-memory-11" /></ul></ul></ul><li>페이징에 대한 하드웨어 지원<ul><li>PTBR (page-table base register)<ul><li>프로세스마다 page table이 다르므로 문맥 교환 (context switch)가 발생할 때 page table도 다른 page table로 갱신될 필요가 있음<li>PTBR은 page table(각 프로세스의 PCB 내에 존재)에 대한 포인터를 저장<li>CPU 내에 존재하는 레지스터</ul><li>TLB (Translation Look-aside Buffer)<ul><li>page table이 main memory에 존재하는 점을 감안하면 main memory에 두 번의 access가 필요<li>(1) page table에 access해서 실제 데이터의 주소를 알아낸 후 (2) 실제 데이터에 access<li>TLB는 이를 해결하기 위한 특별하고 규모가 작고 빠르게 훑는 것이 가능한 하드웨어적인 캐시 메모리 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-12.png" alt="2023-02-05-os-main-memory-12" /></ul></ul><li>페이징 사용 시 메모리의 보호<ul><li>Protection bit을 사용하는 방법<ul><li>page table의 각 entry에 valid/invalid라는 하나의 비트가 더 있음<li>이 비트가 invalid로 설정되면 그 페이지는 프로세스의 논리 주소 공간에 속하지 않는다는 것을 나타냄 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-13.png" alt="2023-02-05-os-main-memory-13" /></ul><li>PTLR(Page Table Length Register, 페이지 테이블 길이 레지스터)을 사용하는 방법<ul><li>프로세스가 제시한 주소가 유효한 범위 내에 있는지를 확인하기 위해 모든 논리 주소 값이 PTLR 값과 비교됨</ul></ul><li>공유 페이지<ul><li>페이징을 사용하면 공유도 수월 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-14.jpg" alt="2023-02-05-os-main-memory-14" /></ul><li>페이지 테이블 page table의 발전<ul><li>page table이 매우 커져서 이를 구축하는 기술이 필요<li>종류<ul><li>계층적 페이징 _Hierarchical Paging<ul><li>2단계 페이징 기법(two-level paging scheme)으로 페이지 테이블 자체가 다시 페이징되게 하는 기법 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-15.jpg" alt="2023-02-05-os-main-memory-15" /> <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-16.png" alt="2023-02-05-os-main-memory-16" /></ul><li>해시 페이지 테이블 _Hashed Page Table<ul><li>해시 페이지 테이블의 각 항목이 연결 리스트를 가지고 있어서 해시 페이지 테이블에서 연결 리스트를 따라가며 첫 번째 원소와 가상 페이지 번호를 비교<li>일치되면 그에 대응하는 페이지 프레임 번호를 가져와 물리 주소를 얻음<li>일치되지 않으면 그다음 원소로 똑같은 행위 반복 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-17.png" alt="2023-02-05-os-main-memory-17" /></ul><li>역 페이지 테이블 _Inverted Page Table<ul><li>시스템에 단 하나의 page table (위에서는 process마다 하나의 page table)<li>page table의 각 entry에 PID 정보 존재 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-18.png" alt="2023-02-05-os-main-memory-18" /></ul></ul></ul><li>스와핑 _Swapping<ul><li>프로세스가 실행되기 위해서는 프로세스의 명령어와 명령어가 접근하는 데이터가 메모리에 있어야 함<li>그러나 프로세스 또는 프로세스의 일부분은 실행 중에 임시로 백업 저장장치(backing store)로 내보내어질 수 있고 다시 메모리에 돌아올 수 있음<li>종류<ul><li>기본 스와핑 _Standard Swapping<ul><li>메인 메모리와 백업 저장장치 간에 전체 프로세스를 이동<li>스와핑(Swapping)이란 용어는 일반적으로 표준 스와핑을 의미<li>표준 스와핑은 기존 UNIX 시스템에서 사용되었지만 메모리와 백업 저장장치 간에 프로세스 전체를 이동하는 데 걸리는 시간이 크기 때문에 최신 운영체제에서는 더는 사용되지 않음 <img data-proofer-ignore data-src="/assets/img/illustrations/2023-02-05-os-main-memory-19.jpg" alt="2023-02-05-os-main-memory-19" /></ul><li>페이징에서의 스와핑 _Swapping with Paging<ul><li>Linux 및 Windows를 포함한 대부분의 시스템은 이제 프로세스 전체가 아닌 프로세스 페이지를 스왑할 수 있는 변형 스와핑을 사용</ul></ul></ul></ol><h2 id="참고">참고</h2><hr /><ol><li>운영체제 공룡책 강의 | 주니온 | 인프런 https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98/dashboard<li><div class="table-wrapper"><table><tbody><tr><td>운영체제 제 10판<td>Abraham Silberschatz, Peter Baer Galvin, Greg Gagne 저/박민규 역<td>퍼스트북<td>2020년 02월 28일</table></div><li>운영체제 제 10판 솔루션 https://codex.cs.yale.edu/avi/os-book/OS10/practice-exercises/index-solu.html</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>CS</a>, <a href='/categories/os/'>OS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cs/" class="post-tag no-text-decoration" >CS</a> <a href="/tags/os/" class="post-tag no-text-decoration" >OS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/?v=1743601323"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Main Memroy - Develiberta&url=https://develiberta.github.io/posts/os-main-memory/?v=1743601323" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Main Memroy - Develiberta&u=https://develiberta.github.io/posts/os-main-memory/?v=1743601323" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Main Memroy - Develiberta&url=https://develiberta.github.io/posts/os-main-memory/?v=1743601323" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/os-definition/?v=1743601323">OS Definition</a><li><a href="/posts/os-storage-management/?v=1743601323">Storage Management</a><li><a href="/posts/os-virtual-memory/?v=1743601323">Virtual Memroy</a><li><a href="/posts/os-main-memory/?v=1743601323">Main Memroy</a><li><a href="/posts/os-deadlocks/?v=1743601323">Deadlocks</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs/?v=1743601323">CS</a> <a class="post-tag" href="/tags/os/?v=1743601323">OS</a> <a class="post-tag" href="/tags/securiy/?v=1743601323">Securiy</a> <a class="post-tag" href="/tags/ansible/?v=1743601323">Ansible</a> <a class="post-tag" href="/tags/devops/?v=1743601323">DevOps</a> <a class="post-tag" href="/tags/linux/?v=1743601323">Linux</a> <a class="post-tag" href="/tags/typography/?v=1743601323">typography</a> <a class="post-tag" href="/tags/algorithm/?v=1743601323">Algorithm</a> <a class="post-tag" href="/tags/favicon/?v=1743601323">favicon</a> <a class="post-tag" href="/tags/getting-started/?v=1743601323">getting started</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/os-thread-02/?v=1743601323"><div class="card-body"> <span class="timeago small" >Oct 23, 2022<i class="unloaded">2022-10-23T13:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS Thread (2)</h3><div class="text-muted small"><p> 목적 CPU 이용의 기본 단위가 된 스레드를 이해한다. 실천 목표 스레드 풀, 포크 조인 및 그랜드 센트럴 디스패치를 포함하여 암시적 스레딩에 대한 다양한 접근 방식을 설명한다. Windows 및 Linux 운영체제가 스레드를 어떻게 나타내는지 설명한다. Pthread, Java 및 Windows 스레딩 API를 사용하여 ...</p></div></div></a></div><div class="card"> <a href="/posts/os-cpu-scheduling-01/?v=1743601323"><div class="card-body"> <span class="timeago small" >Oct 29, 2022<i class="unloaded">2022-10-29T13:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS CPU Scheduling</h3><div class="text-muted small"><p> 목적 CPU 이용의 기본 단위가 된 스레드를 이해한다. 실천 목표 다양한 CPU 스케줄링 알고리즘을 설명한다. 스케줄링 기준에 따라 CPU 스케줄링 알고리즘을 평가한다. 한정된 CPU (코어) 자원과 수많은 프로세스(및 스레드) 한정된 CPU (코어)를 효율적으로 할당하기 위한 스케줄링 필요 기본적인 개념 정리...</p></div></div></a></div><div class="card"> <a href="/posts/os-synchronization-tools/?v=1743601323"><div class="card-body"> <span class="timeago small" >Nov 12, 2022<i class="unloaded">2022-11-12T13:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS Synchronization Tools</h3><div class="text-muted small"><p> 목적 협력적 프로세스가 동시에 데이터에 접근할 때 발생하는 문제를 이해한다. 임계구역 문제에 대한 하드웨어 해결책과 소프트웨어 해결책을 이해한다. 실천 목표 임계구역 문제를 설명하고 경쟁 조건(Race Condition)을 설명한다. 메모리 장벽, compare-and-swap 연산 및 원자적 변수를 사용하여 임계구역 문제...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/os-deadlocks/?v=1743601323" class="btn btn-outline-primary" prompt="Older"><p>Deadlocks</p></a> <a href="/posts/os-virtual-memory/?v=1743601323" class="btn btn-outline-primary" prompt="Newer"><p>Virtual Memroy</p></a></div><script src="https://utteranc.es/client.js" repo="develiberta/blog-comments" issue-term="url" theme="github-light" crossorigin="anonymous" async> </script> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/develiberta">develiberta</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cs/?v=1743601323">CS</a> <a class="post-tag" href="/tags/os/?v=1743601323">OS</a> <a class="post-tag" href="/tags/securiy/?v=1743601323">Securiy</a> <a class="post-tag" href="/tags/ansible/?v=1743601323">Ansible</a> <a class="post-tag" href="/tags/devops/?v=1743601323">DevOps</a> <a class="post-tag" href="/tags/linux/?v=1743601323">Linux</a> <a class="post-tag" href="/tags/typography/?v=1743601323">typography</a> <a class="post-tag" href="/tags/algorithm/?v=1743601323">Algorithm</a> <a class="post-tag" href="/tags/favicon/?v=1743601323">favicon</a> <a class="post-tag" href="/tags/getting-started/?v=1743601323">getting started</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://develiberta.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js?v=1743601323"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js?v=1743601323"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
